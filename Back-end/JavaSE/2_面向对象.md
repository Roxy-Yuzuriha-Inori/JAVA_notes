# 一.类和对象
>类就是数据类型,对象是具体的变量
>对象名存在栈（地址），对象存在堆和方法区（引用类型）
![对象在内存存在形式](./assets/对象存在形式.png)
1. 全局变量与局部变量
全局变量有默认值，局部变量没有，需要赋值
外部类属性变量和局部变量可以重名，访问时遵循就近原则
局部变量前不能加修饰符
2. 对象创建流程
1.在方法区加载类，只会加载一次
2.在堆中分配空间，创建类的属性，其中引用类型的变量会在方法区的常量池中创建
3.完成对象初始化，先默认初始化，再根据类中的内容给age赋初值
4.根据构造器修改属性初值（默认初始化-显式初始化-构造器初始化）
5.在栈中创建对象名，将堆中的地址返回给p，对在堆中的对象能够进行对象引用
![对象创建流程](./assets/对象创建流程.png)

# 二.封装
目的：类里面的属性实现私有化，只能通过公共的setter方法进行访问修改,setter可以制定规则，但是构造器也是public，可以绕过setter制定的规则直接改，所以构造器的方法里面赋值直接用setter方法

## this
this可以访问该类的属性（this.name）全局变量
对象方法里面的this，指向该对象实例。否则只是函数内的局部变量，无论传什么该类的属性都是默认值
```java
//this可以在一个构造器中访问另一个构造器，语法this（参数），而且必须放在第一条语句
public T(int name){
  this.name = name;
}
public T(int name,int age){
//构造器复用
this(name);
this.age = age;
}
```
## 参数绑定
```java
// 1.基本类型参数绑定:形参给了方法内部的参数，各自指向各自的值，双方各自的后续修改，互不影响
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        int n = 15; // n的值为15
        p.setAge(n); // 传入n的值
        System.out.println(p.getAge()); // 15
        n = 20; // n的值改为20
        System.out.println(p.getAge()); // 15还是20?  15
    }
}

class Person {
    private int age;

    public int getAge() {
        return this.age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

// 2.引用类型参数绑定：传递的时候传的是数组的地址，对地址指向的对象内容修改，方法内部的参数内容跟着修改
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        String[] fullname = new String[] { "Homer", "Simpson" };
        p.setName(fullname); // 传入fullname数组
        System.out.println(p.getName()); // "Homer Simpson"
        fullname[0] = "Bart"; // fullname数组的第一个元素修改为"Bart"
        System.out.println(p.getName()); // "Homer Simpson"还是"Bart Simpson"?   Bart Simpson
    }
}

class Person {
    private String[] name;

    public String getName() {
        return this.name[0] + " " + this.name[1];
    }

    public void setName(String[] name) {
        this.name = name;
    }
}

```

# 三.构造方法
```java
//完成新对象初始化（不是创建），方法名和类名相同，没有返回值，由系统自动完成
class Person{
String name;
int age;
//构造器
public Person (String pname,int page)
{name=pname;
age=page;}
}
//调用 Person p1=new Person(“ss”,41);

//构造器重载
public Person (String pname){}

//不自己写构造器默认有构造器，自己声明了构造器不会有默认构造器
public Person(){}

```

# 四.继承和多态
## 访问修饰符
1. 将几个类整合到包，不同包中的类可以重名
2. 创建同名类前要加包名，只有一个可以import然后可以不写包名
3. 只有默认和public可以修饰类
4. protected能访问不同包的子类
![访问修饰符范围](./assets/访问修饰符范围.png)
## 继承
目的：解决代码复用
语法：
```java
class A extends B{
A独有属性
}
A继承了B的属性
```
1.子类不能访问父类的private属性，要通过父类的公共方法（public 数据类型 getxx（））访问
2.只要调用某一子类构造器，就会先调用父类的无参构造器初始化父类（默认会有super()）再调用子类；
如果父类没有无参构造器，则必须在子类的构造器中super(参数)对应父类的有参构造器
3.super必须放在子类构造器第一行，和this只能存在一个
4.所有的类的父类是Object，父类构造器的调用会一直追溯到Object的调用
5.java只能继承一个爸爸，要继承干爸，可以让干爸变成爷爷
### 继承的内存布局
![继承的内存布局](./assets/继承的内存布局.png)
1.new一个son，从object往下到son加载
2.堆中从爷爷（绿）到son（红）写信息，爷爷和son信息分别是独立空间，name不冲突，最后将整个大空间地址给栈中对象名son
3.调用name会从堆的son空间从下往上找，调用遇到的第一个。如果爷爷也有一个age，但爸爸（紫）有个private age ，调用son.age会报错，不会调用到爷爷的age

### super
super可以访问父类的属性和方法  super.属性   
super不局限于父类，父类没有会继续找父类的父类，私有的父类不能访问（报错）
super只能在方法或构造函数内部调用父类的成员
子类没有此方法，要调用父类方法
(1) 方法（）
(2) this.方法()
(3) super.方法      直接查找父类，可适用于子类有重名方法，要访问父类的方法

### 三.重载
传入不同的参数调用不同的解决方案，但方案名字和结果是一样的
1. 方法名必须相同
2. 形参列表必须不同
3. 返回类型无要求
```java
//可变参数
public int sum(int...nums){}
//1.nums可看作数组
//2.可传数组
```
### 重写
子类对父类方法的重写
1. 方法名必须相同
2. 形参列表必须相同
3. 返回类型是父类或父类返回类型的子类
4. 子类方法不能缩小父类方法的访问权限
5. 方法内容重写如果有要用到相同的super.方法

## 多态
通过变化的运行类型动态决定调用哪种子类方法
语法：
Anmal anmal = new Dog();
等号左边的Anmal指明了anmal这个对象引用名的编译类型是Anmal，右边表面现在anmal的运行类型是Dog
1. 等号左边的是编译类型，右边的是运行类型
2. 一个对象的编译类型和运行类型可以不一样
3. 运行类型可以变化,编译类型是不变的
   anmal = new Cat()
左边anmal的编译类型还是Anmal，运行类型变成Cat   
### 向上转型
1. 主函数anmal不能调用子类cat特有的方法（在编译阶段，能调用哪些成员是由编译类型决定的）
2. 调用方法运行时从运行类型开始找方法（调用前提1，即anmal得有这个方法名），先看cat里有没有对应重写的方法（重写作用）
3. 属性看的编译类型，不会先去找子类属性
### 向下转型
1. 语法：子类类型  引用名 = （子类类型）父类引用
2. 只能强转父类的引用，不能强转父类的对象
父类的引用-指向不同对象的变量名 和父类的对象-对象实际数据