### 垃圾回收机制
* 不用的变量会被回收，比如函数里的局部变量，调用完函数就会被回收
* 内存泄漏：内存无法被回收

## 垃圾回收机制算法
1. 引用计数法
存储复杂类型数据的堆中，没有引用即栈中没有地址指向这个数据时就会被回收
存在问题
在堆中两个函数相互引用，就永远有人引用，无法被回收

2. 标记清除法
从根部开始，标记所有可以访问的变量，然后清除所有没有被标记的变量

### 函数闭包
形式：函数A嵌套函数B，函数A中定义变量，函数B中执行队变量的逻辑，最后函数A返回函数B
``` html
<script>
    function outer() {
      let count = 1          //函数A中定义变量
      function fn() {        //函数B中执行对变量的逻辑
        count++
        console.log(`函数被调用${count}次`)
      }
      return fn              //函数A返回函数B
    }
    const re = outer()       //调用函数A中的函数B
    <script>
  ```
  * 优点：函数A中定义的变量实现私有化，因为不是全局变量，所有不会被直接修改；外部函数能使用内部函数变量
  * 缺点：函数A中的变量会通过外部定义的全局变量调用函数A中的函数B，再由函数B找到变量，该变量一直会被引用，造成内存泄漏
  * 问题：为什么函数A里面一定要写个函数返回变量，而不是直接返回变量的值呢？
  因为如果这样，首先外部定义的全局变量接收的是函数A，每次调用就会重新赋值，无法执行逻辑部分

  ### 箭头函数的this  比function多找一层作用域
  正常函数的作用域里面有this，然后看这个函数谁调用的（找正常函数的作用域），this就指向谁
  箭头函数没有this，this是箭头函数的作用域的this，然后再找这个作用域外面的调用者，就是箭头函数的this


