<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>天气案例_监视属性</title>
  <script type="text/javascript" src="../js/vue.js"></script>
</head>

<body>
  <!-- 
		监视属性watch：
				1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作
				2.监视的属性必须存在，才能进行监视！！
				3.监视的两种写法：
					(1).new Vue时传入watch配置
					(2).通过vm.$watch监视
		 -->
  <!-- 
		深度监视：
				(1).Vue中的watch默认不监测对象内部值的改变（一层）。
				(2).配置deep:true可以监测对象内部值改变（多层）。
		备注：
				(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！
		 -->
  <!-- 准备好一个容器-->

		<!-- 
				computed和watch之间的区别：
						1.computed能完成的功能，watch都可以完成。
						2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。
				两个重要的小原则：
							1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。
							2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，
								这样this的指向才是vm 或 组件实例对象。
              3.普通函数data:function(){}简写data(){}   箭头函数data:()=>{}
		-->  
  <div id="root">
    <h2>今天天气很{{info}}</h2>
    <button @click="changeWeather">切换天气</button>
  </div>
</body>

<script type="text/javascript">
  Vue.config.productionTip = false

  const vm = new Vue({
    el: '#root',
    data: {
      isHot: true,
      number: {
        a: 1
      }
    },
    computed: {
      info() {
        return this.isHot ? '炎热' : '凉爽'
      }
    },
    methods: {
      changeWeather() {
        this.isHot = !this.isHot
      }
    },
    //监视属性 第一种方式
    watch: {
      //1.监听isHot属性
      isHot: {
        //初始化时让handler调用一下
        immediate: true,
        //当isHot发生改变时，调用handler函数可以对前后改变的值进行处理
        handler(newValue, oldValue) {
          console.log('isHot被修改了', newValue, oldValue)
        }
      },

      //2.监视多级结构的某一个属性，比如number里面的a   需要''
      'number.a': {
        handler() { }
      },

      //3.监视多级结构的任意一个属性发生改变
      number: {
        //不开启deep，Vue监视的是number后面{}这个对象的地址有没有变化，而不是deep里面的属性
        deep: true,
        handler() { }
      },

      //4.监视属性只有handler时里面的属性可以看作函数简写
      number(hanlder参数){         //形参接收新值

      }
    }
  })
  //监视属性 第二种方式
  vm.$watch('isHot', {
    immediate: true,
    handler(newValue, oldValue) {
      console.log('isHot被修改了', newValue, oldValue)
    }
  })
  //简写，第二个参数传函数，默认是handler
  vm.$watch('isHot',function(){

  })
/*
分析：1.setTimeout如果是普通函数，this指向setTimeout的调用者，是windows
      2.setTimeout如果是箭头函数，this指向firstName函数的this，该函数是Vue的watch属性里面的函数，由Vue管理，Vue会将其this强制指向Vue实例
*/  
  		const v = new Vue({
			el:'#root',
			data:{
				firstName:'张',
				lastName:'三',
				fullName:'张-三'
			},
			watch:{
				firstName(val){
					setTimeout(()=>{
						console.log(this)
						this.fullName = val + '-' + this.lastName
					},1000);
				},
			}
		})

</script>


</html>